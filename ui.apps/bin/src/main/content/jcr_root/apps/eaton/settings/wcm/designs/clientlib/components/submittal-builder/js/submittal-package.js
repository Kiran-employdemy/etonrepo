/**
 *
 *
 *
 * - THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY -
 * - Generated by Gulp (gulp-babel).
 *
 *
 *
 *
 */


'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
  var HIDDEN_CLASS = 'hidden';
  var PACKAGE_CLASS = 'submittal-package';
  var TOGGLE_EDIT_MODE_BUTTON_CLASS = PACKAGE_CLASS + '__toggle-edit-mode-button';
  var TOGGLE_EDIT_MODE_BUTTON_SELECTOR = '.' + TOGGLE_EDIT_MODE_BUTTON_CLASS;
  var REMOVE_ALL_BUTTON_CLASS = PACKAGE_CLASS + '__remove-all-button';
  var REMOVE_ALL_BUTTON_SELECTOR = '.' + REMOVE_ALL_BUTTON_CLASS;
  var MODAL_CLASS = 'submittal-builder__modal';
  var CLOSE_MODAL_CLASS = MODAL_CLASS + '__close';
  var CLOSE_SELECTOR = '.' + CLOSE_MODAL_CLASS;

  var App = window.App || {};
  App.SubmittalPackage = function () {
    _createClass(SubmittalPackage, null, [{
      key: 'markup',
      value: function markup(_ref) {
        var title = _ref.title,
            files = _ref.files,
            editButtonText = _ref.editButtonText,
            closeText = _ref.closeText,
            doneText = _ref.doneText,
            removeAllText = _ref.removeAllText,
            addFilesText = _ref.addFilesText,
            isEditing = _ref.isEditing;

        var fileElements = files.map(function (file) {
          return '<div><a href="' + file.href + '">' + file.title + '</a></div>';
        });
        return '\n        <div class="' + PACKAGE_CLASS + '">\n          <h3 class="' + MODAL_CLASS + '__header ' + PACKAGE_CLASS + '__header">\n            <span class="icon icon-folder ' + PACKAGE_CLASS + '__header__icon" aria-hidden="true"></span>\n            ' + title + '\n          </h3>\n          <button class="button--reset ' + TOGGLE_EDIT_MODE_BUTTON_CLASS + ' ' + (files.length > 0 || isEditing && files.length === 0 ? '' : 'hidden') + '">\n              ' + (isEditing ? doneText : editButtonText) + '\n          </button>\n          <button aria-label="' + closeText + '"\n            class="button--reset ' + CLOSE_MODAL_CLASS + '">\n            <span class="sr-only">' + closeText + ' ' + title + '</span>\n            <i class="icon icon-close" aria-hidden="true"></i>\n          </button>\n          <button class="button--reset ' + REMOVE_ALL_BUTTON_CLASS + ' ' + (!isEditing || files.length === 0 ? 'hidden' : '') + '">\n            ' + removeAllText + '\n          </button>\n          <p class="' + (files.length > 0 ? 'hidden' : '') + '">' + addFilesText + '</p>\n          ' + fileElements.join('') + '\n        </div>\n      ';
      }
    }]);

    function SubmittalPackage(container) {
      _classCallCheck(this, SubmittalPackage);

      // The constructor should only contain the boiler plate code for finding or creating the reference.
      if (typeof container.dataset.ref === 'undefined') {
        this.ref = Math.random();
        App.SubmittalPackage.refs[this.ref] = this;
        container.dataset.ref = this.ref;
        this.init(container);
      } else {
        // If this element has already been instantiated, use the existing reference.
        return App.SubmittalPackage.refs[container.dataset.ref];
      }
    }

    _createClass(SubmittalPackage, [{
      key: 'init',
      value: function init(container, title) {
        this.container = container;
        this.title = this.container.dataset.title;
        this.editButtonText = this.container.dataset.editButtonText;
        this.closeText = this.container.dataset.closeText;
        this.doneText = this.container.dataset.doneText;
        this.removeAllText = this.container.dataset.removeAllText;
        this.addFilesText = this.container.dataset.addFilesText;
        this.isEditing = false;
        this.files = [];

        this.render();
      }
    }, {
      key: 'removeFile',
      value: function removeFile(index) {
        this.files.splice(index, 1);

        this.render();
      }
    }, {
      key: 'addFile',
      value: function addFile(file) {
        this.files.push(file);

        this.render();
      }
    }, {
      key: 'removeAllFiles',
      value: function removeAllFiles() {
        this.files = [];

        this.render();
      }

      /**
       * @function moveFile
       * @param {number} startIndex
       * @param {number} endIndex
       * This will move the file at the indicated start index to the indicated end
       * index and push the other files down to accomodate.
       */

    }, {
      key: 'moveFile',
      value: function moveFile(startIndex, endIndex) {
        if (endIndex >= this.files.length) {
          var k = endIndex - this.files.length + 1;
          while (k--) {
            this.files.push(undefined);
          }
        }
        this.files.splice(endIndex, 0, this.files.splice(startIndex, 1)[0]);

        this.render();
      }
      /**
       * @function get isOpen - check if SubmittalPackage is open (mobile only) and return
       * @returns {boolean}
       */

    }, {
      key: 'open',

      /**
       * @function open - shows SubmittalPackage on mobile
       */
      value: function open() {
        this.container.classList.remove(HIDDEN_CLASS);
      }
      /**
       * @function close - hides SubmittalPackage on mobile
       */

    }, {
      key: 'close',
      value: function close() {
        this.container.classList.add(HIDDEN_CLASS);
        this.container.dispatchEvent(new CustomEvent('closed'));

        this.resetState();
      }
      /**
       * @function makeEditable - enables editing mode
       * triggers a re-render
       */

    }, {
      key: 'makeEditable',
      value: function makeEditable() {
        this.isEditing = true;

        this.render();
      }
      /**
       * @function applyChanges - applies the changes in the modal
       * if there are no items in this.files, also close the window
       */

    }, {
      key: 'applyChanges',
      value: function applyChanges() {
        this.isEditing = false;

        // TODO: commit modified state

        if (this.size === 0) {
          this.container.classList.add(HIDDEN_CLASS);
        }
      }
      /**
       * @function toggleEditMode - toggle the isEditing property
       * triggers a re-render
       */

    }, {
      key: 'toggleEditMode',
      value: function toggleEditMode() {
        if (this.isEditing) {
          this.applyChanges();
          this.isEditing = false;
        } else {
          this.isEditing = true;
        }

        this.render();
      }

      /**
       * @function resetState - return the form state to its initial form
       * triggers a re-render
       */

    }, {
      key: 'resetState',
      value: function resetState() {
        console.log('reset state');
        this.isEditing = false;
        // TODO: discard any changes made to the package list and revert to previously saved version

        this.render();
      }
    }, {
      key: 'render',
      value: function render() {
        this.container.innerHTML = App.SubmittalPackage.markup(this);
        this.closeButton = this.container.querySelector(CLOSE_SELECTOR);
        this.toggleEditModeButton = this.container.querySelector(TOGGLE_EDIT_MODE_BUTTON_SELECTOR);
        this.removeAllButton = this.container.querySelector(REMOVE_ALL_BUTTON_SELECTOR);
        this.addEventListeners();
      }

      /**
       * @function addEventListener - A method to allow clients to add event listeners
      *  to this component. Calls the addEventListener method of this components containing element.
       */

    }, {
      key: 'addEventListener',
      value: function addEventListener() {
        return this.container.addEventListener.apply(this.container, arguments);
      }

      /**
       * @function removeEventListener - A method to allow clients to remove event listeners
      *  from this component. Calls the removeEventListener method of this components containing element.
       */

    }, {
      key: 'removeEventListener',
      value: function removeEventListener() {
        return this.container.removeEventListener.apply(this.container, arguments);
      }

      /**
       * @function addEventListeners - Adds event listeners for the internal implementation
       * of this component.
       */

    }, {
      key: 'addEventListeners',
      value: function addEventListeners() {
        var _this = this;

        this.closeButton.addEventListener('click', function () {
          return _this.close();
        });
        this.toggleEditModeButton.addEventListener('click', function () {
          return _this.toggleEditMode();
        });
        this.removeAllButton.addEventListener('click', function () {
          return _this.removeAllFiles();
        });
      }
    }, {
      key: 'size',
      get: function get() {
        return this.files.length;
      }
    }, {
      key: 'estimatedZipSize',
      get: function get() {
        return this.files.reduce(function (totalSize, file) {
          return totalSize + file.size;
        }, 0);
      }
    }, {
      key: 'isOpen',
      get: function get() {
        return !this.container.classList.contains(HIDDEN_CLASS);
      }
    }]);

    return SubmittalPackage;
  }();

  App.SubmittalPackage.refs = {};
})();